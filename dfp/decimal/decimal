/* <decimal> for libdfp and redirect to system <decimal>

   Copyright (C) 2011-2015 Free Software Foundation, Inc.

   This file is part of the Decimal Floating Point C Library.

   Author(s): Ryan S. Arnold <rsa@us.ibm.com>

   The Decimal Floating Point C Library is free software; you can
   redistribute it and/or modify it under the terms of the GNU Lesser
   General Public License version 2.1.

   The Decimal Floating Point C Library is distributed in the hope that
   it will be useful, but WITHOUT ANY WARRANTY; without even the implied
   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
   the GNU Lesser General Public License version 2.1 for more details.

   You should have received a copy of the GNU Lesser General Public
   License version 2.1 along with the Decimal Floating Point C Library;
   if not, write to the Free Software Foundation, Inc., 51 Franklin
   Street, Fifth Floor, Boston, MA 02110-1301 USA.

   Please see libdfp/COPYING.txt for more information.  */

#ifndef _LIBDFP_DECIMAL_H
#define _LIBDFP_DECIMAL_H 1

#ifdef _GLIBCXX_DECIMAL_IMPL
# error "dfp/<decimal/decimal> should be #included before the system <decimal/decimal> header."
#endif

#ifdef __cplusplus

/* This needs to be declared before #include_next <decimal/decimal> so that
 * _Decimal types are declared when the system <decimal/decimal> pulls in
 * other headers which are overloaded by libdfp, e.g., wchar.h.  */
#include <float.h> /* Pick up _Decimal[32|64|128] typedefs.  */

/* Pick up the system <decimal>. Since C++ DFP support is currently only a
 * technical report the decimal header is in the non-default search path so
 * <decimal/decimal> must be used.  */
#include_next <decimal/decimal>
using namespace std::decimal;

#pragma GCC system_header

#include <ostream>
using std::ostream;

#include <istream>
using std::istream;

#include <string>
using std::string;

#include <iostream>
using namespace std;

#include <stdlib.h> /* Pick up the strtod[32|64|128] prototypes.  */
#include <stdio.h>  /* Pick up the sprintf prototype.  */
#include <limits.h> /* For CHAR_MAX.  */
#include <string.h> /* For memset.  */

template<unsigned int size>
struct FIND_DEC_MANT_DIG
{
  enum {RESULT = 0};

  static inline std::string get_fmt(char conv)
  {
     std::string spec = "";
     return spec;
  }
};

template <>
struct FIND_DEC_MANT_DIG<4>
{
  enum {RESULT = (__DEC32_MANT_DIG__) };
  static inline std::string get_fmt(char conv)
  {
     std::string spec = "H";
     return spec.append(1,conv);
  }
};
template <>
struct FIND_DEC_MANT_DIG<8>
{
  enum {RESULT = (__DEC64_MANT_DIG__) };
  static inline std::string get_fmt(char conv)
  {
     std::string spec = "D";
     return spec.append(1,conv);
  }

};
template <>
struct FIND_DEC_MANT_DIG<16>
{
  enum {RESULT = (__DEC128_MANT_DIG__) };
  static inline std::string get_fmt(char conv)
  {
     std::string spec = "DD";
     return spec.append(1,conv);
  }
};

/* Template meta-programming so we only have to write this code once for use
 * with each of the _Decimal[32|64|128] types.  */
template<class decimal_type>
class LIBDFP_META {
private:
public:
  static inline ostream & decimal_to_string(std::ostream &os, decimal_type &d)
    {
      /* If strbuf is big enough for a _Decimal128, it is big enough for the
       * other types as well, so just use the same size for all of them.
       *   1  (leading zero)
       * + 1  (.)
       * + 34 (__DEC128_MANT_DIG__)
       * + 1  (e)
       * + 1  (+/-)
       * + 4  (digits in __DEC128_MAX_EXP__)
       * + 1  "\n"
       * = 43 -> round up to a power of 2 = 64.  */

      char strbuf[64];

      ios_base::fmtflags flags = os.flags();
      unsigned int precision = os.precision();

      /* Anything over DEC_MANT_DIG can't be represented anyway.  */
      if (precision > DEC_MANT_DIG)
        precision = DEC_MANT_DIG;

      char conv = 'g';

      std::string fmtstr = "%";

      /* A strict reading of the draft DFP C++ spec indicates that a/A conv
         specifier can't be accompanied by a precision specifier.  */

      if (flags & ios::fixed && flags & ios::scientific)
	  conv = flags & ios::uppercase ? 'A' : 'a';
      else
        {
	  if (flags & ios::fixed)
	      /* Only used for "NAN" and "INF" rather than "nan" and "inf" for
	       * "%.*Df".  */
	      conv = flags & ios::uppercase ? 'F' : 'f';
	  else if (flags & ios::scientific)
	      conv = flags & ios::uppercase ? 'E' : 'e';
	  else if (flags & ios::uppercase)
	      conv = 'G';
	  fmtstr.append(".*");
	}

      /* Get the conv spec and length modifier based on size of the type.  */
      fmtstr.append(FIND_DEC_MANT_DIG<(sizeof(decimal_type))>::get_fmt(conv));

      /* Per the confusing reading of the draft DFP C++ Specification, a/A type
         are never passed with an accompanying precision.  This causes the
	 implicit precision in the type to be used for printing.  */
      if (flags & ios::fixed && flags & ios::scientific)
        sprintf (strbuf, fmtstr.c_str(), d.__getval());
      else
        sprintf (strbuf, fmtstr.c_str(), precision, d.__getval());
      os << strbuf;
      return os;
    }

  enum {DEC_MANT_DIG = FIND_DEC_MANT_DIG<(sizeof(decimal_type))>::RESULT};
};

/* Per ISO/IEC JTC1 SC22 WG21 N2732 - TR 24733: "Extension for the programming
 * language C++ to support decimal floating point arithmetic" define the
 * ostream and istream operators.  These are included in libdfp and NOT
 * libstdc++ because the ostream and istream operators rely upon libdfp
 * printf and strtod[32|64|128] support provided by libdfp.  */

namespace std
{

  namespace
  {
    struct _Save_errno
    {
      _Save_errno() : _M_errno(errno) { errno = 0; }
      ~_Save_errno() { if (errno == 0) errno = _M_errno; }
      int _M_errno;
    };

    // calls setlocale(LC_ALL, "C") and returns a string containing the old
    // locale name. Caller must delete[] the string. Returns NULL on error.
    const char*
    __set_C_locale()
    {
      char* __old = setlocale(LC_ALL, 0);
      const size_t __len = strlen(__old) + 1;
      char* __sav = new(nothrow) char[__len];
      if (__sav)
	{
	  memcpy(__sav, __old, __len);
	  setlocale(LC_ALL, "C");
	}
      return __sav;
    }
  }

  template<>
    void
    __convert_to_v(const char* __s, decimal::decimal32& __v, ios_base::iostate& __err,
		   const __c_locale&) throw()
    {
      // Assumes __s formatted for "C" locale.
      const char* __sav = __set_C_locale();
      if (!__sav)
	{
	  __err = ios_base::failbit;
	  return;
	}
      char* __sanity;
      bool __overflow = false;

      __v = strtod32(__s, &__sanity);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 23. Num_get overflow result.
      if (__sanity == __s || *__sanity != '\0')
	{
	  __v = 0.0df;
	  __err = ios_base::failbit;
	}
      else if (__overflow
	       || __v == decimal::decimal32 {__builtin_infd32()}
	       || __v == decimal::decimal32 {-__builtin_infd32()}
	      )
	{
	  if (__v > decimal::decimal32 {0.0df})
	    __v = DEC32_MAX;
	  else
	    __v = -DEC32_MAX;
	  __err = ios_base::failbit;
	}

      setlocale(LC_ALL, __sav);
      delete [] __sav;
    }

  template<>
    void
    __convert_to_v(const char* __s, decimal::decimal64& __v, ios_base::iostate& __err,
		   const __c_locale&) throw()
    {
      // Assumes __s formatted for "C" locale.
      const char* __sav = __set_C_locale();
      if (!__sav)
	{
	  __err = ios_base::failbit;
	  return;
	}
      char* __sanity;

      __v = strtod64(__s, &__sanity);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 23. Num_get overflow result.
      if (__sanity == __s || *__sanity != '\0')
	{
	  __v = decimal::decimal64 {0.0dd};
	  __err = ios_base::failbit;
	}
      else if (
	       __v == decimal::decimal64 {__builtin_infd64()}
	       || __v == decimal::decimal64 {-__builtin_infd64()} )
	{
	  if (__v > decimal::decimal64 {0.0dd})
	    __v = DEC64_MAX;
	  else
	    __v = -DEC64_MAX;
	  __err = ios_base::failbit;
	}

      setlocale(LC_ALL, __sav);
      delete [] __sav;
    }

  template<>
    void
    __convert_to_v(const char* __s, decimal::decimal128& __v,
		   ios_base::iostate& __err, const __c_locale&) throw()
    {
      // Assumes __s formatted for "C" locale.
      const char* __sav = __set_C_locale();
      if (!__sav)
	{
	  __err = ios_base::failbit;
	  return;
	}

      char* __sanity;
      __v = strtod128(__s, &__sanity);

      // _GLIBCXX_RESOLVE_LIB_DEFECTS
      // 23. Num_get overflow result.
      if (__sanity == __s || *__sanity != '\0')
	{
	  __v = decimal::decimal128 {0.0dl};
	  __err = ios_base::failbit;
	}
       else if (
	  __v == decimal::decimal128 {__builtin_infd128()}
	  || __v == decimal::decimal128 {-__builtin_infd128()} )
	{
	  if (__v > decimal::decimal128 {0.0dl})
	    __v = DEC128_MAX;
	  else
	    __v = -DEC128_MAX;
	  __err = ios_base::failbit;
	}

      setlocale(LC_ALL, __sav);
      delete [] __sav;
    }



  template<typename _CharT, typename _InIter = std::istreambuf_iterator<_CharT>>
  class dfp_num_get : public num_get<_CharT, _InIter> {
      typedef _InIter iter_type;

  protected:
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
        decimal::decimal32&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
        decimal::decimal64&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
        decimal::decimal128&) const;

  public:
      iter_type
      get(iter_type in, iter_type end, ios_base& io,
     ios_base::iostate& err, decimal::decimal32& v) const
      { return this->do_get(in, end, io, err, v); }

      iter_type
      get(iter_type in, iter_type end, ios_base& io,
          ios_base::iostate& err, decimal::decimal64& v) const
      { return this->do_get(in, end, io, err, v); }

      iter_type
      get(iter_type in, iter_type end, ios_base& io,
          ios_base::iostate& err, decimal::decimal128& v) const
      { return this->do_get(in, end, io, err, v); }
  };

  template<typename _CharT, typename _InIter>
    _InIter
    dfp_num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, decimal::decimal32& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, locale::facet::_S_get_c_locale());
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    dfp_num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, decimal::decimal64& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, locale::facet::_S_get_c_locale());
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    dfp_num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, decimal::decimal128& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = this->_M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, locale::facet::_S_get_c_locale());
      if (__beg == __end)
        __err |= ios_base::eofbit;
      return __beg;
    }

  template <class charT, class traits = char_traits<charT>>
  class dfp_basic_istream;

  namespace decimal
  {
    template <class charT, class traits>
    std::dfp_basic_istream<charT, traits> &
      operator>>(std::dfp_basic_istream<charT, traits> & is, decimal32 & d);
  }

  template <class charT, class traits>
  class dfp_basic_istream : public basic_istream<charT, traits>
  {

    template<class X, class Y>
    friend dfp_basic_istream<X, Y> &
      decimal::operator>>(dfp_basic_istream<X, Y> & is, decimal::decimal32 & d);

    template<class X, class Y, class T>
    friend basic_istream<X, Y> &
      decimal::operator>>(basic_istream<X, Y> & is, T & d);

    template<typename _ValueT>
    dfp_basic_istream<charT, traits> &
    _M_extract(_ValueT& d);
  };

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      dfp_basic_istream<_CharT, _Traits>&
      dfp_basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
        typename basic_istream<_CharT, _Traits>::sentry __cerb(*this, false);
        if (__cerb)
          {
            ios_base::iostate __err = ios_base::goodbit;
            __try
              {
                locale dfp_locale {this->_M_ios_locale, new dfp_num_get<_CharT>()};
                auto& facet {use_facet<dfp_num_get<_CharT>>(dfp_locale)};
                facet.get(*this, 0, *this, __err, __v);
              }
            __catch(__cxxabiv1::__forced_unwind&)
              {
                this->_M_setstate(ios_base::badbit);
                __throw_exception_again;
              }
            __catch(...)
              { this->_M_setstate(ios_base::badbit); }
            if (__err)
              this->setstate(__err);
          }
        return *this;
      }

namespace decimal
{
  //ISO/IEC TR 24733 - 3.2.11 Formatted output:

  template <class charT, class traits>
  inline std::basic_ostream<charT, traits> &
    operator<<(std::basic_ostream<charT, traits> & os, decimal32 d)
    {
      LIBDFP_META<std::decimal::decimal32>::decimal_to_string(os, d);
      return os;
    }

  template <class charT, class traits>
  inline std::basic_ostream<charT, traits> &
    operator<<(std::basic_ostream<charT, traits> & os, decimal64 d)
    {
      LIBDFP_META<std::decimal::decimal64>::decimal_to_string(os, d);
      return os;
    }

  template <class charT, class traits>
  inline std::basic_ostream<charT, traits> &
    operator<<(std::basic_ostream<charT, traits> & os, decimal128 d)
    {
      LIBDFP_META<std::decimal::decimal128>::decimal_to_string(os, d);
      return os;
    }

//  ISO/IEC TR 27433 - 3.2.11 Formatted input:
  template <class charT, class traits>
    inline std::dfp_basic_istream<charT, traits> &
      operator>>(std::dfp_basic_istream<charT, traits> & is, decimal32 & d)
      { return is._M_extract(d); }

  template <class charT, class traits>
    inline std::dfp_basic_istream<charT, traits> &
      operator>>(std::dfp_basic_istream<charT, traits> & is, decimal64 & d)
      { return is._M_extract(d); }

  template <class charT, class traits>
    inline std::dfp_basic_istream<charT, traits> &
      operator>>(std::dfp_basic_istream<charT, traits> & is, decimal128 & d)
      { return is._M_extract(d); }

  template <class charT, class traits, class T>
    inline std::basic_istream<charT, traits> &
      operator>>(std::basic_istream<charT, traits> & is, T & d)
      {
        static_assert(
            std::is_same<T, decimal::decimal32>::value
              || std::is_same<T, decimal::decimal64>::value
              || std::is_same<T, decimal::decimal128>::value,
            "This template function is only meant to be used with "
            "decimal floating point types"
        );

        auto& dfpIstream {
          static_cast<
            dfp_basic_istream<charT, traits>&
          >(is)
        };

        dfpIstream._M_extract(d);

        return is;
      }

} /* namespace decimal  */
} /* namespace std  */

#else
# warning "dfp/<decimal/decimal> should only be #included by C++ programs."
#endif /* __cplusplus  */

#endif /* _LIBDFP_DECIMAL_H  */
